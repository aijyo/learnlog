// [package]
// name = "df_test"
// version = "0.1.0"
// edition = "2021"

// [dependencies]
// tract-onnx = "0.21"
// ndarray = "0.15"

use ndarray::Array4;
use tract_onnx::prelude::*;

fn print_cpp_vector(name: &str, data: &[f32]) {
    // Print like C++ std::vector<float>
    println!("std::vector<float> {} = {{", name);
    for (i, v) in data.iter().enumerate() {
        if i % 8 == 0 {
            print!("    ");
        }
        print!("{:.9e}f", v);
        if i + 1 != data.len() {
            print!(", ");
        }
        if i % 8 == 7 {
            println!();
        }
    }
    println!("\n}};\n");
}

fn tensor_to_f32_vec(t: &Tensor) -> TractResult<Vec<f32>> {
    // Convert tensor to a flat Vec<f32> (contiguous)
    let view = t.to_array_view::<f32>()?;
    Ok(view.iter().copied().collect())
}

fn main() -> TractResult<()> {
    let model_path = r"D:\code\mycode\onnx_mlir_test\model_shim\3rd\deepfilter\lib\enc.onnx";


    // -----------------------------
    // Input 0: feat_erb (1, 1, 1, 32)
    // -----------------------------
    let enc_input10_data: Vec<f32> = vec![
    1.708396971e-1, 3.488453031e-1, 1.762540787e-1, -2.114420012e-2, -3.559608385e-2, -2.049369812e-1,
    -2.041631639e-1, -1.752944887e-1, -2.880403399e-1, -3.005224168e-1, -1.327016801e-1, -1.762481630e-1,
    -1.335769594e-1, 1.082403213e-1, 1.800828874e-1, -1.204706207e-1, -1.080387086e-1, -1.316509210e-2,
    3.766994551e-2, 2.996458113e-1, 6.671785116e-1, 5.717741251e-1, 3.531543612e-1, 3.104232848e-1,
    2.743015289e-1, 2.175287306e-1, 1.293848008e-1, 7.199458778e-2, 3.911991045e-2, 3.165607527e-2,
    -2.154808119e-2, -1.612033881e-2,
    ];

    // let feat_erb =
    //     Array::from_shape_vec((1, 1, 1, 32), enc_input10_data)?;
    let feat_erb_arr: Array4<f32> = Array4::from_shape_vec((1, 1, 1, 32), enc_input10_data)?;
    let feat_erb_vec: Vec<f32> = feat_erb_arr.into_raw_vec();
    let feat_erb: Tensor = Tensor::from_shape(&[1usize, 1usize, 1usize, 32usize], &feat_erb_vec)?;

    // -----------------------------
    // Input 1: feat_spec (1, 2, 1, 96)
    // -----------------------------
    let enc_input11_data: Vec<f32> = vec![
    2.353111096e-2, 8.338645846e-2, -7.246287167e-2, -9.890937805e-2, 6.210913509e-2, 1.366040204e-2,
    9.928160347e-3, -2.319277450e-2, 1.471612323e-2, -1.001845463e-3, 3.240516176e-3, 1.441666391e-3,
    2.182230586e-3, -6.168862339e-3, -4.468978441e-4, 2.324269153e-3, 3.610172134e-4, 1.761338557e-3,
    -1.122143934e-3, -3.435176332e-3, -1.189539209e-3, 5.560854916e-3, -2.964996034e-3, -2.669172129e-3,
    1.166786678e-4, 5.038972013e-3, 4.089768045e-3, -9.641822428e-3, 6.519699935e-3, -1.374612469e-2,
    2.148291841e-2, -1.820990816e-2, -2.067461173e-4, 1.181792747e-2, -4.046748858e-3, 2.044091467e-3,
    -4.976226017e-3, -7.582296384e-4, -1.429140568e-3, 4.240047652e-3, 2.718893113e-3, 8.894430939e-4,
    -7.586444844e-4, -1.951813116e-3, -3.540905018e-4, -1.522429753e-3, 6.240999792e-4, 5.122961011e-3,
    -4.018411040e-3, -5.605031620e-4, -1.895641210e-3, -2.132376394e-4, 7.739719003e-4, 3.336259164e-3,
    1.853292051e-4, -8.741036290e-4, -7.760660723e-3, 1.151561271e-2, 5.594996037e-4, -4.940163810e-3,
    -4.143941216e-3, 1.210319926e-3, 2.037559403e-3, 4.077180289e-3, -2.288523829e-3, -7.426985074e-3,
    1.026083366e-3, 1.520492043e-2, 1.570423949e-3, -1.811715402e-2, -1.002281439e-2, 8.992459625e-3,
    1.269647572e-2, 9.731695056e-3, 4.813967098e-4, -2.764274180e-2, -1.348658931e-2, 2.679471672e-2,
    2.068736032e-2, -3.815400973e-2, -1.256840676e-1, 2.284752429e-1, -5.513889343e-2, 2.302185073e-2,
    1.306622010e-2, -1.883458644e-1, 1.569399834e-1, -9.661182016e-2, 9.385868907e-2, -7.226286083e-2,
    8.932734281e-2, -5.464142188e-2, -4.474439472e-2, 9.026741982e-2, -8.012557030e-2, -5.528548732e-2,
    0.000000000e0, 4.015728831e-2, 1.230657250e-1, -9.129229933e-2, -4.535132647e-2, 1.545795426e-2,
    1.414827351e-2, 1.069974038e-3, -1.584276743e-2, 1.133755594e-2, -6.790325511e-3, 6.545054261e-3,
    1.039830386e-4, 6.420639344e-3, -8.455194533e-3, 3.515482647e-3, -2.755687106e-3, 3.855293384e-3,
    5.161304725e-4, 2.327302005e-3, -6.214308552e-3, 1.617741655e-3, 3.956459463e-3, -2.932556905e-3,
    -1.989662880e-3, -4.480124451e-3, 1.088145375e-2, -3.479086794e-3, 3.278546734e-3, -5.436545704e-3,
    -3.887031926e-3, 1.887273416e-2, -2.473984845e-2, 1.034641173e-2, -1.922437921e-3, 6.082206964e-3,
    -2.543504583e-3, 9.718866204e-4, -6.118158344e-3, -7.214037032e-5, -5.404320545e-4, 4.603852052e-3,
    -1.837172313e-4, 2.462312346e-3, -2.409957116e-3, 1.782584703e-3, -5.800391547e-3, 4.799524322e-3,
    1.297100214e-3, 4.950410221e-4, -1.847531530e-3, -2.474066860e-4, -3.898317926e-3, 2.213817788e-3,
    2.742918150e-4, 5.473287310e-3, -6.739232223e-3, -4.232734907e-3, 9.498560801e-3, 1.974956831e-3,
    -2.605470596e-3, -3.812409937e-3, -1.199785504e-3, 1.721020089e-3, 5.751498975e-3, -2.062422922e-3,
    -1.077957731e-2, 2.288123942e-4, 1.797230169e-2, 5.535276607e-3, -1.526805852e-2, -1.277546119e-2,
    -8.892374899e-5, 8.738649078e-3, 1.878759637e-2, 1.103525795e-2, -3.265571967e-2, -9.129382670e-3,
    2.066807263e-2, 5.205076188e-2, -9.567347914e-2, -9.619323909e-2, 1.872034520e-1, -1.181727424e-1,
    2.158837318e-1, -1.499727964e-1, -8.958825842e-3, 1.247634087e-2, -2.365818061e-2, 2.176623233e-2,
    -3.286833689e-2, 9.536680579e-2, -9.051951766e-2, 1.782974601e-2, 7.934822887e-2, -1.447940171e-1,
    ];

    // let feat_spec =
    //     Array::from_shape_vec((1, 2, 1, 96), enc_input11_data)?;
    let feat_spec_arr: Array4<f32> = Array4::from_shape_vec((1, 2, 1, 96), enc_input11_data)?;
    let feat_spec_vec: Vec<f32> = feat_spec_arr.into_raw_vec();
    let feat_spec: Tensor = Tensor::from_shape(&[1usize, 2usize, 1usize, 96usize], &feat_spec_vec)?;
    


    // Run inference
    
    // Load and prepare model
    let runnable = tract_onnx::onnx()
        .model_for_path(model_path)?
        .into_optimized()?
        .into_runnable()?;

    // Run twice (match your C++ behavior)
    for run_idx in 0..2 {
        let outputs = runnable.run(tvec![feat_erb.clone().into(), feat_spec.clone().into()])?;

        println!("==============================");
        println!("RUN {} OUTPUTS:", run_idx);

        // Output order: e0,e1,e2,e3,emb,c0,lsnr
        let names = ["e0", "e1", "e2", "e3", "emb", "c0", "lsnr"];

        for (i, tv) in outputs.into_iter().enumerate() {
            let name = if i < names.len() { names[i] } else { "out" };

            // In recent tract versions, TValue -> Tensor via into_tensor()
            let t: Tensor = tv.into_tensor();

            let vec = tensor_to_f32_vec(&t)?;
            print_cpp_vector(name, &vec);
        }
    }

    Ok(())
}
